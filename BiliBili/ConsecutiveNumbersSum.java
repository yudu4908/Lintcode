package BiliBili;
//给定一个正整数 N，试求有多少组连续正整数满足所有数字之和为 N?  1 <= N <= 10 ^ 9.
public class ConsecutiveNumbersSum {
    /**
    输入: 9
输出: 3
解释: 9 = 9 = 4 + 5 = 2 + 3 + 4
     */

     /**
    这题就是推到数学公式,并不好做
    这道题给了一个正整数N，问N能写成多少种连续正整数之和，比如9可以写成 4+5，或者 2+3+4。
    这道题其实不好做，因为没有固定的算法可以套，而更多的考察是数学知识，
    而且比较难想。由于要写成连续正整数之和，则肯定是一个等差数列，并且差值为1，
    这个等差数列不必从1开始，假设其是从x开始的，且个数共有k个，则可以写出这个等差数列为：
x, x+1, x+2, ..., x+k-1
其和为N，根据等差数列的求和公式，可以写出下列等式：

kx + (k-1)k / 2 = N
变形后可得到：

kx = N - (k-1)k / 2
这样，只要对于任意一个k值，x能得到正整数解，就表示一定会有一个对应的等差数列和为N。下面要来求k的范围，由于k是等差数列的长度，首先肯定是要大于0的，这是下限。求上限还是要利用上面的那个式子，由于x也必须是正整数，可以得到不等式：

N - (k-1)k / 2 > 0
从而得到近似解：

k < sqrt(2N)
有了k的范围就可以开始遍历了，首先数字N本身也是符合题意的，可以看作是长度为1的等差数列，则 res 可以初始化为1，
然后k从2遍历到 sqrt(2N)，对于每个k值，只要 (N - k(k-1)/2) 能整除k，就表示存在长度为k的等差数列和为N，
结果 res 自增1，这样就可以求出所有符合题意的等差数列的个数，

      */
    public int consecutiveNumbersSum(int N) {
        int count = 1;
        for (int k = 2; k < Math.sqrt(2 * N); k++) {
            if ((N - (k * (k - 1) / 2)) % k == 0) {
                count++;
            }
        }
        return count;
    }
}